title: 并发编程-线程池的使用
author: v-vampires
date: 2020-01-13 23:27:39
tags:
---
## 为什么使用线程池
无论是对象池还是线程池，池化的作用就是缓存对象或者线程，进而重复使用。我们常用创建线程的方法就是创建Thread对象，由于java中的线程是和操作系统的线程一一对应的，如果频繁创建和销毁线程，就会大大地浪费时间并影响程序的性能，因而线程池可以很好的解决这个问题
## 线程池
线程池的核心类是java.util.concurrent.ThreadPoolExecutor，主要构造方法如下：
```
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```
### 参数  
corePoolSize：核心线程池大小，如果核心线程池没有满，新的任务就会被新建的一个核心线程执行，执行完毕后不会销毁线程，线程会读取工作队列中的任务继续执行，如果队列中没有任务，则线程阻塞,当队列中有任务后，线程被唤醒继续执行

maximumPoolSize：线程池能创建的最大的线程数量，如果核心线程和缓存队列都已经满了，新的任务进来
就会被新建的线程执行，但是线程数量不能超过maximumPoolSize的大小。如果线程数量已经达到maximumPoolSize，则新来的任务就会执行拒绝策略  

keepAliveTime：非核心线程空闲后能够存活的最长时间，超过次时间，线程终止

unit：时间单位，配合keepAliveTime使用

workQueue：工作队列，用来存放被执行的任务。我们往线程池提交的就是任务

threadFactory：线程工厂，用来创建线程

handler：任务被拒绝后的处理策略.默认提供的4种拒绝处理策略
1. java.util.concurrent.ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出异常
2. java.util.concurrent.ThreadPoolExecutor.DiscardPolicy：丢弃任务，不抛出异常
3. java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy：丢弃工作队列种最前面的任务，然后尝试重新执行次任务
4. java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理此任务

## 线程池处理流程
添加任务时：（1）如果当前线程数小于核心线程数，则创建新线程（构造一个worker对象）执行；（2）如果大于等于核心线程数，则添加到任务队列，（3）当任务队列满了以后，则创建新线程执行；（4）当线程数大于最大线程数时，则执行拒绝策略。当线程执行完当前的任务后，则会从队列中获取任务继续执行。如果队列中没有则阻塞，因此线程并不会死亡。除非线程池关闭或者是超过core的线程的空闲时间达到keepAliveTime。正常的应用应该是绝大多数的任务应执行步骤2，也就是将任务添加到队列。当超过核心数的线程空闲时间达到keepAliveTime时，则终止该线程
## 注意
使用线程池提交任务时，如果任务在执行过程中出现运行异常，会导致执行任务的线程终止；而且任务异常终止，我们却获取不到通知，会让人误以为线程正常执行，因此需要在任务里面捕获异常