title: 并发编程-等待通知机制
author: v-vampires
date: 2020-01-10 19:25:56
tags:
categories: 
- 并发编程
---
## 介绍
一个完整的等待通知流程是：线程首先获得互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁。其中，使用线程阻塞的方式就能避免循环等待消耗 CPU 的问题。这个和锁的机制是一样的，锁是获取不到资源，自动阻塞线程；等待通知机制则是条件不满足，主动阻塞自己。
## 用 synchronized 实现等待通知机制
### 原理
synchronized可以配合wait(),notify(),notifyAll()来实现等待通知机制。  

使用synchronized互斥锁时，同一个时刻，只允许一个线程进入synchronized保护的临界区，当有一个线程进入临界区后，其他线程就只能进入该锁对应的锁标志等待队列。当进入临界区的线程由于条件不满足，就需要调用wait(),阻塞当前线程，当前线程就会进入到该锁的另一个队列也就是对象等待队列中。当线程要求的条件满足时，调用锁对象的notify或者notifyAll方法，来通知等待的线程，通知的过程就是将对象等待队列中的线程移动到锁标志等待队列。notify是随机移动一个，notifyAll是移动所有。  

注意，我们应该尽量使用notifyAll,因为我们可能因为不同的条件而放入同一个对象等待队列中，使用notify可能会通知错（比如：线程1因为条件A不满足进入了等待队列，线程2因为条件B不满足也进入了等待队列，而线程3因为条件A满足而通知其他线程时，有可能通知的是线程2，而线程2的条件还没有满足无法唤醒，而线程1却没有机会唤醒了），如果确实只有一个条件变量则可以使用notify。
### 示例

## 用ReentrantLock和Condition实现等待通知机制
### 原理
ReentrantLock可以Condition的await，signal，signalAll来实现等待通知机制

ReentrantLock+Condition的原理与synchronized的原理基本一致，也是使用队列的方式。除了性能的差异外，还有就是每一个Condition有一个自己的对象等待队列，例如：我们使用notFull和notEmpty两个条件，当使用notFull.await时，当前线程会被加入到notFull对应等待队列，当其他线程调用notFull.singal时将从notFull的队列中唤醒一个线程。因此，Condition能使通知粒度更细，通过将不同条件的等待线程分到不同的等待队列中，从而进行准确通知

### 示例（LinkedBlockingQueue）
```
    //出队列，需要队列不空
    public E take() throws InterruptedException {
        E x;
        int c = -1;
        final AtomicInteger count = this.count;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();
        try {
            
            while (count.get() == 0) {//队列空了
                notEmpty.await();//不空的条件不满足，即等待对列不空
            }
            x = dequeue();
            c = count.getAndDecrement();//获取出队列之前的count
            if (c > 1)//如果出队之后还有其他元素，则可以通知其他的读线程继续
                notEmpty.signal();
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)//如果原来是满的队列，则现在不满了，通知写线程可以写了
            signalNotFull();
        return x;
    }
    
    //入队列，需要队列不满
    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly();
        try {
            while (count.get() == capacity) {//队列满了
                notFull.await();//不满条件不满足，则等待队列不满
            }
            enqueue(node);
            c = count.getAndIncrement();//获取入队之前的count
            if (c + 1 < capacity)//入队一个元素之后还没满，则通知其他其他写线程继续
                notFull.signal();
        } finally {
            putLock.unlock();
        }
        if (c == 0)//如果入队之前是空的，则现在不空了，通知读线程可以读了
            signalNotEmpty();
    }
```
