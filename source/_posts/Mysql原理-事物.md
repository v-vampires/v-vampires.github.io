title: Mysql原理-事物
author: v-vampires
date: 2020-02-25 10:31:56
tags:
---
## 事物的目的
事物可以理解为是一组数据库操作，事物的目的就是保证数据库的这组组操作要么全部成功，要么全部失败。Mysql中，事物支持是再引擎层实现的，MyISAM引擎就不支持事物，InnoDB则支持事物。当数据库上有多个事物同时执行的时候，就可能出现脏读、不可重复读、幻读的问题

## 脏读、不可重复读、幻读
### 脏读
脏读是指读到别人未提交的数据。A事务读取B事务尚未提交的数据，此时如果B事物发生错误并执行回滚操作，那么A读取到的就是脏数据。示例如下
![upload successful](/images/pasted-19.png)
### 不可重复读
不可重复读是指前后多次读取，数据内容不一致。不可重复读是针对同一条数据的update操作，读取到了其他事物更改的数据。解决：使用行级锁
![upload successful](/images/pasted-20.png)
### 幻读
幻读是指前后多次读取数据总量不一样，幻读是读取了其他事物新增的数据，针对的是insert操作。解决：使用表级锁，锁定整张表
![upload successful](/images/pasted-21.png)

## 事物的隔离级别
为了防止出现脏读、不可重复读、幻读这些问题，数据库有4个隔离级别来解决他们。分别是：
1. 读未提交：读到别人没有提交的数据。也就是一个事物还没有提交时，它的变更就能被别的事物看到
2. 读已提交：读到别人已经提交的数据。也就是一个事物提交后，它的变更才能被其他事物看到
3. 可重复读：一个事物执行过程中看到的数据，总是跟这个事物再启动时看到的数据是一致的
4. 串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

示例如下：
![upload successful](/images/pasted-22.png)
我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么
1. 读未提交：v1=2，v2=2，v3=2；事物A可以看到事物B未提交的变更
2. 读已提交：v1=1，v2=2，v3=2；事物A可以看到事物B提交的变更
3. 可重复读：v1=1，v2=1，v3=2；事物A在事物开启期间数据不变
4. 串行化：v1=1，v2=1，v3=2；事物B会被卡住，直到事物A提交

不同的隔离级别对应的不同问题如下：
![upload successful](/images/pasted-23.png)

## 事物隔离的实现
1. 读未提交：直接返回记录上的最新值，由于会产生脏读，不适合使用
2. 读已提交：视图是在每次一致性读的时候（也就是开启事物并执行select语句）创建的，这样的好处就是在执行第一个和第二个select的之间，如果其他事物提交了，这样第二个select就能看见其他事物提交的数据。因此再读已提交的隔离级别下，一个事物可能会包含多个视图
3. 可重复读：视图是在事物开始的第一个select时候创建的，此后任意的select都不会再产生视图，也就是整个事物期间都用这一个视图
4. 串行化：通过读写锁的方式来避免并发，由于并发性太差，不适合使用


### MVCC
以上所说的视图就是通过MVCC（数据的多版本并发控制来）来实现的。MVCC简单理解就是一条数据库记录存在多个版本。在mysql中、实际上每条记录再更新的时候都会记录一条回滚操作，也就是undolog，记录上的最新值，都可以通过回滚操作得到前一个状态的值。再可重复读的隔离级别下，事物启动的时候声明：“以我启动的时刻为准，如果一个数据版本是在我启动之前的我就认；如果是再我启动之后生成的，我就不认，我必须找到它的上一个版本”

### 一致性读与当前读

![upload successful](/images/pasted-25.png)

	以上图为例：在RR隔离级别下，假如有事物A与事物B，事物A早于事物B先开启事物，但是事物B先进行了update操作，并提交了事物。这个时候如果事物A执行select语句，根据一致性读原则事物A并不能读取到B提交的修改，而是读取历史版本的数据；但是如果事物A执行的是set k=k+1这样的update语句，因为我们知道执行update语句要先读取数据，这个时候时候事物A是可以读取到事物B提交的修改嘀（因为如果还读取历史版本的数据，那么事物B的更新就丢失了）。这里就用到了当前读：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。当然如果事物B进行了update，但是没有提交事物，那么写锁就不会释放（锁是在事物提交后释放），因此事物A由于是当前读必须枷锁，会因此而锁住。    

当前读除了update、insert还有select for update

注意：
1. Mysql默认的隔离级别就是RR（可重复读），一致性读的时候使用MVCC可以避免不可重复读和幻读
2. 再业务开发中，一般并发问题会采用乐观锁、分布式锁的方案。在RR隔离级别下，如果使用乐观锁更新失败，那么再重新开一个事物进行重试

